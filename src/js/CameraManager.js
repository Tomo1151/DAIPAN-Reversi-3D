import*as o from"three";import{getRandomInt as i,sleep as t}from"./Utils.js";export default class e{#gameManager;#rendererManager;#scene;#camera;#hasMoveCompleted=true;#target;#originalPosition;constructor(t,e,a){this.#gameManager=t;this.#rendererManager=e;this.#scene=a;this.#camera=e.camera}update(){if(!this.#hasMoveCompleted)this.move()}async shake(){this.controlable=false;const[t,e,a]=[i(2,10),i(2,10),i(2,10)];this.#camera.lookAt(t,e,a);setTimeout(()=>{this.#camera.lookAt(new o.Vector3(0,0,0));this.controlable=true},i(50,75))}moveTo(t,e,a,o,i,s,r){this.#gameManager.logger.log(` |~ camera: move to (${t.toPrecision(3)}, ${e.toPrecision(3)}, ${a.toPrecision(3)})`);this.#originalPosition=JSON.parse(JSON.stringify(this.#camera.position));this.#target={x:t,y:e,z:a,lookAt:o,controlable:i,callback:s,step:r};this.#hasMoveCompleted=false}move(){this.controlable=this.#target?.controlable;let t=this.#target.x-this.#camera.position.x;let e=this.#target.y-this.#camera.position.y;let a=this.#target.z-this.#camera.position.z;let o=this.#target.step?this.#target.step:50;this.#camera.position.x+=t/o;this.#camera.position.y+=e/o;this.#camera.position.z+=a/o;this.#camera.lookAt(this.#target.lookAt.x,this.#target.lookAt.y,this.#target.lookAt.z);if(Math.abs(t)<.05&&Math.abs(e)<.05&&Math.abs(a)<.05){this.#camera.position.set(this.#target.x,this.#target.y,this.#target.z);this.#hasMoveCompleted=true;if(this.#target.callback)this.#target.callback();this.#gameManager.logger.log(` |~ camera: moved to (${this.#target.x.toPrecision(3)}, ${this.#target.y.toPrecision(3)}, ${this.#target.z.toPrecision(3)})`);this.#target=undefined}}restore(t){let e=this.#originalPosition;this.moveTo(e.x,e.y,e.z,new o.Vector3(0,0,0),true,()=>{this.controlable=true;t()},10)}set controlable(t){this.#rendererManager.controls.enabled=t}}
