<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>demo</title>

	<!-- JS Load -->
	<script type="importmap">
		{
			"imports": {
				"three": "./lib/three.js/build/three.module.js",
				"three/addons/": "./lib/three.js/jsm/"
			}
		}
	</script>
	<style type="text/css">
		body {
			margin: 0;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			outline: none;
			-webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
		}
		canvas {margin: 0; width: 100%; height: 100%;}
	</style>
</head>
<body>
	<canvas id="main-canvas"></canvas>
	<script type="module">
		import * as THREE from "three"
		import { OrbitControls } from "three/addons/controls/OrbitControls.js";
		import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

		window.addEventListener('load', init);

		async function init() {
			const width = 960;
			const height = 540;

			const canvasElement = document.querySelector('#main-canvas');

			// レンダラーを作成
			const renderer = new THREE.WebGLRenderer({
				antialias: true,
				canvas: canvasElement
			});
			renderer.setSize(width, height);
			renderer.setPixelRatio(window.devicePixelRatio);

			// シーンを作成
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);

			// カメラを作成
			const camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
			// カメラの初期座標を設定（X座標:0, Y座標:0, Z座標:0）
			camera.position.set(30, 30, 30);

			// 箱を作成
			const geometry = new THREE.BoxGeometry(500, 500, 500);
			const material = new THREE.MeshStandardMaterial({color: 0x0000FF});
			const box = new THREE.Mesh(geometry, material);
			// scene.add(box);

			// カメラコントローラーを作成
			const controls = new OrbitControls(camera, canvasElement);

			// 平行光源
			const light = new THREE.DirectionalLight(0xFFFFFF);
			light.intensity = 2; // 光の強さを倍に
			light.position.set(1, 1, 1); // ライトの方向
			// シーンに追加
			scene.add(light);

			let mixer;
			let clock = new THREE.Clock();
			const disks = [];

			// モデルのロード
			await model_load('model_data/Disk.glb', (data) => {
				const gltf = data;
				const obj = data.scene;
				const animations = gltf.animations;

				console.log(data)

				obj.position.set(0, 0, 0);
				obj.scale.set(5, 5, 5);

				if(animations && animations.length) {

					//Animation Mixerインスタンスを生成
					mixer = new THREE.AnimationMixer(obj);
					console.log(animations);

					//全てのAnimation Clipに対して
					for (let i = 0; i < animations.length; i++) {
						let animation = animations[i];

						//Animation Actionを生成
						let action = mixer.clipAction(animation) ;

						//ループ設定（1回のみ）
						action.setLoop(THREE.LoopOnce);

						//アニメーションの最後のフレームでアニメーションが終了
						action.clampWhenFinished = true;

						//アニメーションを再生
						// action.play();
					}
				}
				disks.push(data);
				scene.add(obj);
			});

			console.log(disks[0].scene.rotation);
			console.log(disks[0]);

			let frame = 0;
			let cnt = 0
			async function flip(disk, cnt) {
				let action = mixer.clipAction(disk.animations[cnt%2]);
				let duration = disk.animations[cnt%2].duration;
				action.setLoop(THREE.LoopOnce);
				action.play();
				await sleep(duration*1000);
				action.stop();
				disk.scene.rotation.z += Math.PI;
				disk.scene.rotation.z %= 2 * Math.PI;
			}

			tick();
			function tick() {
				// レンダリング
				requestAnimationFrame(tick);
				renderer.render(scene, camera);
				if (frame % 250 == 0) {
					flip(disks[0], cnt);
					console.log(disks[0].scene.rotation);
				}

				frame ++;
				cnt++;
				// if (frame % 100 == 0) action.play();
				// if (frame % 105 == 0) console.log(disks[0].scene.rotation);
				// if (frame % 175 == 0) action.stop();
				// if (frame % 175 == 0) disks[0].scene.rotation.z =+ Math.PI;


				// if (frame == 100) action.play();
				// if (frame == 175) action.stop();
				// if (frame == 175) disks[0].scene.rotation.z =+ Math.PI;
				// if (frame == 175) console.log(disks[0].scene.rotation);

				// if (frame % 305 == 0) disks[0].scene.rotation.z = 2 * Math.PI;

				//Animation Mixerを実行
				if(mixer){
					mixer.update(clock.getDelta());
				}
			}
		}

		async function model_load(fbx_path, on_load_func) {
			const loader = new GLTFLoader();
			return new Promise(res => {
				loader.load(fbx_path, (obj) => {
					on_load_func(obj);
					res();
				});
			});
		}

		async function sleep(ms) {
			return new Promise((res) => {setInterval(res, ms)});
		}
	</script>
</body>
</html>